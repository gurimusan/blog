<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> coursera 機械学習 8週目 &middot; gurimusan blog </title>


<link rel="stylesheet" href="https://gurimusan.github.io/blog/css/slim.css">
<link rel="stylesheet" href="https://gurimusan.github.io/blog/css/highlight.min.css">
<link rel="stylesheet" href="https://gurimusan.github.io/blog/css/mathjax.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://gurimusan.github.io/blog/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="https://gurimusan.github.io/blog/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="gurimusan blog" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="https://gurimusan.github.io/blog/">gurimusan blog</a></h1>
  <p class="site-tagline"></p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
       
	  <li class="spacer">&ac;</li>
  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
        <div class="post">
          <h2 class="post-title"><a href="https://gurimusan.github.io/blog/2017/12/coursera-%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92-8%E9%80%B1%E7%9B%AE/">coursera 機械学習 8週目</a></h2>
          <span class="post-date">Dec 4, 2017 </span>
          <div class="post-content">
            

<h1 id="教師なし学習-unsupervised-learning">教師なし学習(Unsupervised Learning)</h1>

<h2 id="クラスタリング-clustering">クラスタリング(Clustering)</h2>

<h3 id="教師なし学習-イントロダクション-unsupervised-learning-introduction">教師なし学習: イントロダクション(Unsupervised Learning: Introduction)</h3>

<p>ラベルなしのデータセットから学習することを、<strong>教師なし学習(Unsupervised Learning)</strong>という。</p>

<p>教師なし学習のトレーニングセットには、ラベルがない。なので教師なし学習では、データセットからデータ構造を探す。</p>

<p>データセットからデータ構造を探すためにクラスタリングというアルゴリズムがある。</p>

<p>データセットからデータ構造を探すためのアルゴリズムは、他にも幾つかあるが、まずはクラスタリングを学ぶ。</p>

<h3 id="k-meansアルゴリズム-k-means-algorithm">K-Meansアルゴリズム(K-Means Algorithm)</h3>

<p>クラスタリングアルゴリズムであるK-Meansアルゴリズムを学ぶ。</p>

<p><strong>K-Meansアルゴリズム</strong>を文章で書くと下記のとおり。</p>

<ol>
<li>各クラスタの中心点(Centroid)を決める: データ$x$と同次元にあるK個のクラスタの中心点 $u_1, u_2,&hellip;, u_{K} \in \mathbb{R}^{n}$ を求める</li>
<li>データセットの要素をクラスタの割り付ける: 中心点$u_1, u_2,&hellip;, u_{K}$と$x$との距離を求めて、最も距離が近いクラスタを割り付ける</li>
<li>クラスタの中心点を更新する: クラスタへ割り付けられた要素$x$の平均を算出して、新たなクラスタの中心点(Centroid)を更新する</li>
<li>クラスタの割り付けによる移動がなくなるまで2-3を繰り返す</li>
</ol>

<h3 id="目的関数の最適化-optimization-objective">目的関数の最適化(Optimization Objective)</h3>

<p><strong>K-Meansアルゴリズム</strong>の目的関数は、$x$とクラスタの中心点$u$を使って下記のように定義される。</p>

<p>$$
\displaystyle J(c^{(1)},&hellip;,c^{(m)},u_{1},&hellip;,u_{K}) = \frac{1}{m} \sum_{i=1}^{m} |x^{(i)} - u_{c^{(i)}}|
$$</p>

<p><strong>K-Meansアルゴリズム</strong>では、この目的関数を最小化するクラスタを選択することが推奨される。</p>

<p>$$
\displaystyle min_{c^{(1)},&hellip;,c^{(m)},u_{1},&hellip;,u_{K}} J(c^{(1)},&hellip;,c^{(m)},u_{1},&hellip;,u_{K}b
$$</p>

<h3 id="ランダム初期化-random-initialization">ランダム初期化(Random Initialization)</h3>

<p>最初にランダムにクラスタをトレーニングセットにピックする。</p>

<p><strong>K-Meansアルゴリズム</strong>は局所最適解に収束しうるが、最適解を得るために、<strong>K-Meansアルゴリズム</strong>100回実行して、その中でコスト関数が最も小さくなるものを選べば良い。</p>

<h3 id="クラスタ数の選択-choosing-the-number-of-clusters">クラスタ数の選択(Choosing the Number of Clusters)</h3>

<p>クラスタの数はどうやって選ぶのか？</p>

<p>多くの場合は、人が決める。</p>

<p>自動的に決める方法とし、エルボー法というアルゴリズムがある。</p>

<p>エルボー法はクラスタ数$K$を徐々に増やしていき、コスト関数の変化量が一番大きいクラスタ数$K$を選ぶ方法。</p>

<p>ただし、クラスタ数$K$を増やしても、コスト関数の変化量があまりかわらない場合は、クラスタ数を決めることができない。</p>

<p>その場合は、そもそもどういった目的でクラスタを分けたいのか、ということからクラスタ数を決める。</p>

<h1 id="次元数の削減-dimensionality-reduction">次元数の削減(Dimensionality Reduction)</h1>

<h2 id="動機-motivation">動機(Motivation)</h2>

<h3 id="動機ⅰ-データ圧縮-motivation-i-data-compression">動機Ⅰ: データ圧縮(Motivation I: Data Compression)</h3>

<p>データ圧縮は、より少ないメモリやディスク容量にデータを圧縮するだけでなく、学習アルゴリズムのスピードアップにもなる。</p>

<p>2次元から1次元に削減する場合、2次元の要素${x^{1},x^{2},&hellip;,x^{n}} \in \mathbb{R}^{2}$を1次元に射影するという近似を行い、1次元の要素${z^{1},z^{2},&hellip;,z^{n}} \in \mathbb{R}^{1}$を求める。</p>

<p>次元数が増えても、n次元からk次元に削減する場合、n次元の要素${x^{1},x^{2},&hellip;,x^{n}} \in \mathbb{R}^{n}$をk次元に射影するという近似を行い、k次元の要素${z^{1},z^{2},&hellip;,z^{n}} \in \mathbb{R}^{k}$を求める。</p>

<h3 id="動機ⅱ-データ可視化-motivation-ii-visualization">動機Ⅱ: データ可視化(Motivation II: Visualization)</h3>

<p>次元数を削減することで、データを可視化できるようになる。</p>

<p>データを可視化できれば、よりデータを理解できるようになる。</p>

<h2 id="主成分分析-principal-component-analysis">主成分分析(Principal Component Analysis)</h2>

<h3 id="主成分分析問題の定式化-principal-component-analysis-problem-formulation">主成分分析問題の定式化(Principal Component Analysis Problem Formulation)</h3>

<p>次元数を削減するアルゴリズムのうち、最もポピュラーなのは<strong>主成分分析(Principal Component Analysis)</strong>、<strong>PCA</strong>とも呼ばれるアルゴリズムである。</p>

<p><strong>PCA</strong>の原理は、n次元のデータ$x$をk次元まで減らすとき、<strong>PCA</strong>はn次元空間でのk次元のベクトルへの投射した時の距離(投射誤差(Projection Error))を最小にするベクトルを見つけることである。</p>

<p>2次元から1次元に削減する場合は、2次元の各点からの直線へ射影した距離を最小化するベクトルを選択する。</p>

<p>3次元から2次元に削減する場合は、3次元の各点から平面へ射影した距離を最小化するベクトルを選択する。</p>

<p><strong>PCA</strong>は線形回帰と一緒ではない。</p>

<h3 id="主成分分析問題のアルゴリズム-principal-component-analysis-algorithm">主成分分析問題のアルゴリズム(Principal Component Analysis Algorithm)</h3>

<p>まず、必ず説明変数のスケーリングを行い、説明変数を比較可能な範囲にする。</p>

<p>平均値$u_{j}$を計算する。</p>

<p>$$
u_j = \frac{1}{m} \sum_{i=1}^{m} x_{j}^{(i)}
$$</p>

<p>$x_{j}^{(i)}$を$x_{j} - u_{j}$を$\sigma$で割った値で置き換える($\sigma$は標準偏差)。</p>

<p>$$
x_{j}^{(i)} = \frac{x_{j} - u_{j}}{\sigma}
$$</p>

<p>次に<strong>共分散行列(Covariance Matrix)</strong>を計算する。</p>

<p>$$
\sum = \frac{1}{m}\sum^n_{i=1}(x^{(i)})(x^{(i)})^{\mathrm{T}}
$$</p>

<p>Octaveでは、下記のように計算する。</p>

<pre><code class="language-octave">sigma = (X'*X)/m;
</code></pre>

<p>共分散行列の固有値(eigenvector)$U$を計算する。</p>

<p>$$
AU = \lambda U
$$</p>

<p>Octaveでは下記のように計算する。</p>

<pre><code class="language-octave">[U,S,V] = svd(sigma);
</code></pre>

<p>新しい次元ベクトルzzを固有ベクトル (eigenvector)から計算する。</p>

<p>$$
Z = U^{T}X
$$</p>

<p>Octaveでは下記のように計算する。</p>

<pre><code class="language-octave">Ureduce = U(:,1:k);
Z = Ureduce'*X;
</code></pre>

<p>上記の式では、$k$まで次元を減少させたいので$n \times n$の行列$U$の最初の$k$個の固有ベクトルを使って計算している。</p>

<h2 id="applying-pca">Applying PCA</h2>

<h3 id="圧縮状態からの復元-reconstruction-from-compressed-representation">圧縮状態からの復元(Reconstruction from Compressed Representation)</h3>

<p>固有値$U$の左からかけることで、元の行列$X$が求まる。</p>

<p>$$
Z = U^{T}X \\<br />
UZ = X_{approx}
$$</p>

<h3 id="主成分の数の選択-choosing-the-number-of-principal-components">主成分の数の選択(Choosing the Number of Principal Components)</h3>

<p>圧縮する次元数$k$を選ぶためのガイドラインを与える。</p>

<p>$X$と$X_{approx}$の差の2乗をとって割合を計算して、$0.01$以下であれば良い。</p>

<p>$$
\frac{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)} - x_{approx}^{(i)}||}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2} \leq 0.01
$$</p>

<p>$0.01$以外に$0.01〜0.15$くらいまでなら一般的に有効な値となる。</p>

<p>この式を使って、下記のように$k$を$1,2,3&hellip;,n$と加算していって、$0.01$以下となる値を見つける。</p>

<ol>
<li>kを1に初期化する</li>
<li>$U_{reduce}$, $z^{(1)},z^{(2)},&hellip;,z^{(m)}$, $x_{approx}^{(1)},&hellip;,x_{approx}^{(m)}$を計算する</li>
<li>$\frac{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)} - x_{approx}^{(i)}||}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2}$を計算する</li>
<li>3で計算した値が$0.01$を超える場合は$k=k+1$として2に戻る</li>
</ol>

<p>下記の式はより効率的な式に置き換えることが可能。</p>

<p>$$
\frac{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)} - x_{approx}^{(i)}||}{\frac{1}{m}\sum_{i=1}^{m}||x^{(i)}||^2} \leq 0.01
$$</p>

<p>共分散行列の固有値(eigenvector)$U$の計算において算出される固有値行列$S$を使って、下記のように書ける</p>

<p>$$
1 - \frac{\sum_{i=1}^{k} S_{i,i}}{\sum_{i=1}^{n} S_{i,i}} \leq 0.01 \\<br />
\frac{\sum_{i=1}^{k} S_{i,i}}{\sum_{i=1}^{n} S_{i,i}} \geq 0.99
$$</p>

<h3 id="advice-for-applying-pca">Advice for Applying PCA</h3>

<p>PCAはトレーニングセットにだけ実行して、トレーニングセットへPCAを使って得られた$U_{reduce}$を、クロス検証セットやテストセットに適用する。クロス検証セットやテストセットに対してPCAを適用してはいけない。</p>

<p>PCAはオーバーフィッティグを防ぐ方法として使ってはいけない。おそくらうまくいくが、使ってはいけない。</p>

<p>オーバーフェッティングを防ぐなら、正規化を使うべきで、正規化の方が単純にうまく機能する。</p>

<p>PCAは次元数を削減するため、重要な何かを捨てしまってしまう可能性もあるため、おすすめしない。</p>

          </div>
        </div>
        <div class="pagination">
          <a class="btn previous " href="https://gurimusan.github.io/blog/2017/12/coursera-%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92-10%E9%80%B1%E7%9B%AE/"> Prev</a>  
          <a class="btn next " href="https://gurimusan.github.io/blog/2017/12/coursera-%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92-7%E9%80%B1%E7%9B%AE/"> Next</a> 
        </div>
      </div>
    </div>
    
    <div class="footer">
  
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
  
</div>

  </div>
  <script src="https://gurimusan.github.io/blog/js/slim.js"></script>
  <script src="https://gurimusan.github.io/blog/js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  displayAlign: 'left',
  displayIndent: '1em',
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[','\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: {
      equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"]
    }
  },
  CommonHTML: { linebreaks: { automatic: true } },
  "HTML-CSS": { linebreaks: { automatic: true } },
         SVG: { linebreaks: { automatic: true } }
});
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  
</body>

</html>
